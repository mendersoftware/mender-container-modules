#!/bin/sh
# Copyright 2025 Northern.tech AS
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

# This Mender Update Module was derived from the Application Update Module at
# https://github.com/mendersoftware/app-update-module.

set -e

DOCKER_CMD="docker"
DOCKER_COMPOSE_CMD=""

CONFIG_FILE="/etc/mender/mender-docker-compose.conf"

if test -f "$CONFIG_FILE"; then
    . "$CONFIG_FILE"
fi

discover_docker_compose() {
    local rc=0
    local compose_version
    if test -n "$DOCKER_COMPOSE_CMD"; then
        $DOCKER_COMPOSE_CMD version < /dev/null > /dev/null 2>&1
        rc=$?
    elif $DOCKER_CMD compose version < /dev/null > /dev/null 2>&1; then
        DOCKER_COMPOSE_CMD="$DOCKER_CMD compose"
    elif docker-compose version < /dev/null > /dev/null 2>&1; then
        DOCKER_COMPOSE_CMD="docker-compose"
    else
        echo "ERROR: could not find executable for Docker Compose" 1>&2
        echo "ERROR: is Docker Compose installed?" 1>&2
        rc=1
    fi
    if test $rc -eq 0; then
        compose_version=$($DOCKER_COMPOSE_CMD version --short)
        case "$compose_version" in
            "2."*)  ;;
            *)
                echo "Docker Compose v2 is required; installed version: ${compose_version}"
                rc=1
                ;;
        esac
    fi
    return $rc
}

assert_specific_requirements() {
    if ! $DOCKER_CMD --version > /dev/null < /dev/null 2>&1; then
        echo "ERROR: cannot find command \"${DOCKER_CMD}\" in PATH"
        echo "ERROR: is Docker installed?"
        return 1
    fi
    if ! $DOCKER_CMD version > /dev/null; then
        echo "ERROR: failed to connect with the Docker API"
        return 1
    fi
    discover_docker_compose || return 1

    return 0
}

container_image_save() {
    local application_name="$1" # TODO
    local url="$2"
    local output_file="$3"

    $DOCKER_CMD image save "$url" -o "$output_file"
}

container_image_load() {
    local url="$1"
    local input_file="$2"

    $DOCKER_CMD image load < "$input_file"
}

comp_stop() {
    local application_name="$1"
    local manifests_dir="$2"

    $DOCKER_COMPOSE_CMD \
        --project-directory "$manifests_dir" \
        --project-name "$application_name" \
        down >> "$manifests_dir"/compose.log 2>&1
}

comp_start() {
    local application_name="$1"
    local manifests_dir="$2"
    local rc=0

    $DOCKER_COMPOSE_CMD \
        --project-directory "$manifests_dir" \
        --project-name "$application_name" \
        up -d --wait --remove-orphans > "$manifests_dir"/compose.log 2>&1
    rc="$?"
    if test "$rc" != "0"; then
        echo "Failed to start composition, logs follow:" 1>&2
        cat "$manifests_dir/compose.log" 1>&2
        docker_compose_cmd \
            --project-directory "$manifests_dir" \
            --project-name "$application_name" \
            logs -t 1>&2
        return $rc
    fi
    return 0
}

clean_up() {
    local app_dir="$1"

    if test -f "$app_dir"/images/urls; then
        xargs $DOCKER_CMD image rm < "$app_dir"/images/urls
    fi
}

# We define the module-specific functions above first, then we load the generic
# common part which uses the above functions and handles the Update Module API.
. $(dirname "$0")/container-modules-common.sh
